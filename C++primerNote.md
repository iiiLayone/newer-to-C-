#### 列表初始化  39页
使用花括号赋初值
```
int num = {1};
```
#### 区别初始化和赋值 39页
- 初始化：创建变量时赋予初始值
- 赋值：把对象当前值擦除，以一个新值替代
####  如何选择类型 32页
```
整型选int
浮点 double
明确非负 unsigned
表达式中少用bool char
```
#### 默认初始化 
如果定义变量时没有指定初始值，那么：
- 定义于任何函数体之外的变量被初始化为0
- 定义于函数体内部的内置类型变量将不被初始化  （其值未定义，试图拷贝或访问会报错）
- 类对象如果未被显示初始化，其值由类决定。
建议初始化每一个内置类型变量
#### 声明与定义
- 声明：使得名字为程序所知      （规定了变量的类型和名字）
- 定义：负责创建与名字关联的实体 规定了变量的类型和名字还申请了存储空间，也可能会赋初值

如果想声明而非定义：
```
extern int i;  //声明i而非定义  只是声明就使用这种形式 告诉编译器应该到该文件外部去找这个文件的定义
int j;         //声明并定义j
extern int i = 10;   //如果包含初始值就不再是声明而变成定义了
```
**变量只可以被定义一次，但是可以多次声明**

使用每个变量前必须声明其类型。
#### 标识符
- 变量名一般全是小写字母
- 类名大写字母开头
- 多个单词要有明显区分

建议第一次使用变量时再定义它
#### 引用
引用的类型必须与其引用对象的类型一致 但是存在2个例外

第一种，初始化常量引用时可以允许任何表达式作为初始值。
```
double dval=3.14;
const int &r1=dval;

//const int&temp=dval;
//const int &r1=temp;  这种情况下，ri绑定了临时变量
//临时变量：编译器需要一个空间来暂存表达式的求值结果时临时创建的未命名对象
``` 

#### 指针
```
int *dp1,*dp2; //定义几个指针变量每个都需要有*
double dp,*dp3;   //dp是double型对象，dp3是指向double类型的指针
```
引用不是对象没有实际地址，不可以定义指向引用的指针

指针是对象而引用不是
```
//int & *p = &b;
```
试图拷贝或者以其他方式访问无效指针都会引发错误。

尽量等定义了对象之后再定义指向它的指针，实在不知道只想哪里，就初始化nullptr或者0。

建议初始化所有指针
#### nullptr
现在多使用**nullptr**,避免使用NULL
#### void* 56页
可用于存放任意对象的地址，但是不清楚地址中到底是什么类型的对象

#### 指向指针的引用 52页
面对复杂的指针或者引用声明语句，从右向左阅读

#### const 限定符 53页
const对象一旦创建后其值不能改变所以必须初始化。

默认情况下，const对象被设定为仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义独立的变量。

解决方法是，不管是声明还是定义都添加extern关键字,以实现多个文件之间共享const对象
```
extern const int bufsize=fun();
```
对const的引用简称为"常量引用"，仅对对const的操作做出了限定，对的引用的对象本身未作限定

#### 顶层const 57页
- 顶层const表示指针本身是一个常量  ，一般来说顶层const可以表示任意的对象是常量
- 底层const表示所指的对象是一个常量，而底层const则与指针和引用等复合类型有关，用于声明引用的const都是底层const
```
int * const p1=&i;   //不能改变p1的值，顶层
const int *p2=&i;    //允许改变p2的值，是一个底层
```
执行对象拷贝操作时，顶层const和底层const区别明显
- 顶层const不受什么影响
- 底层的限制不能忽视 拷入和拷出的对象必须具有相同的底层const，或者两个对象数据类型必须能相互转换
#### constexptr和常量表达式
值不会改变并且在编译过程就能得到计算结果
```
const int MAX=20;   //是 
int i=10;           //不是 不是const int
const in sz=func(); //具体值等到运行时才能获取，所以不是
```
声明为constexpr的变量一定是一个常量，且必须用常量表达式初始化。

确定变量是一个常量表达式，就把它声明称constexpr类型
#### const 和指针
```
const double pi=3.14;
const double *ctpr = &pi; //指向常量的指针  不能够通过指针改变对象的值
```
指针类型必须与所指对象类型一致，但是存在两个例外：

允许常量指针指向非常量对象
```
double dval=3.14;
const double *cptr=&dval;
```
#### 常量指针 56页
```
int *const v = &num;  //把指针自己定义为一个常量，地址也就是指向不可改变 可修改值
```
#### 指针和constexptr
```
const int *p=nullptr;       //指向整型常量的指针
constexptr int *q=nullptr;  //指向整数的常量指针    顶层const
```
#### typedef 60页
```
typedef double base,*p;    // base是double的同义词，p是double*的同义词
```
新标准 using
#### auto 61
让编译器替我们分析所属的类型
#### decltype 62
选择并返回操作数的数据类型（得到类型，却不计算表达式的值）
- 如果表达式内容时解引用操作，decltype将得到引用类型，必须初始化 
- decltype((val)) （双层括号）的结果永远时引用
- decltype(val)    直接返回该变量的类型，只有当val是引用时才是引用
```
//decltype(*p) c ;  //错误，引用必须初始化  

```
#### 自定义数据结构 64
类右侧表示结束一定写一个分号，因为类后面可以紧跟变量名以示对该类型对象的定义（**不建议**）

可以为数据成员提供**类内初始值**

#### 头文件 67
为了确定各个文件中类的定义一致，类通常被定义在头文件中，且类所在的头文件与类名字一样
#### 预处理器 68
预处理变量无视C++中关于作用域的规则
```
#define  //指令把一个名字设定为预处理变量
#ifdef   //当且仅当变量已定义时为真
#ifndef  //当且仅当变量未定义时为真
#endif   //结束指令
```
一般预处理变量名字全部**大写**

没必要在乎程序需要与否，习惯性的加上要

#### 命名空间的using声明 
头文件不因该包含using声明

#### string  77
```
string s;
cin>>s;   
// string 对象会自动忽略开头的空白（空格符、换行符、制表符等）从第一个真正的字符读起，直到遇到下一处空白       
```
empty()和size()都是string的成员函数

size()的返回类型是**string::size_type**无符号的整数。

一条语句有了size()再用int，unsigned和int一起可能会带来问题
#### getline函数读取一整行 78
- 可以保留字符串输入时的空白符
- 函数的参数是一个输入流和一个string对象
- 函数从给定输入流读取内容，直到换行符停止（换行符也被读进来了）
- 将所读的内容存入到string对象中，不存换行符（一开始就是换行符，则空string）

#### 字面值和string相加
```
string s1;
string s2=s1+"d";
string s3 = "dff"+"dff";    //错误 两个运算对象都不是string
string s4 = "dff"+"dff"+s1; //错误 不能把字面值相加
```
**字符串字面值**并不是标准库类型string的对象。字符串字面值和string是不同类型











