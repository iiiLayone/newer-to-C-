## 内存分区模型
C++在执行程序时，内存大方向划分为四个区域：代码区，全局区，栈区，堆区。

意义：不同区域存放的数据赋予不同的生命周期，更大的灵活编程。
### 程序运行前
在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域
#### 代码区
存放CPU执行的二进制机器指令。特点：共享，只读。
#### 全局区
该区域的数据在程序结束后由操作系统释放

常量：
1. 字符串常量：双引号引起来的
2. const修饰的变量：
   - const修饰的全局变量 
   - const修饰的局部变量

全局区：全局变量、静态变量（普通变量前加static 是静态变量）、常量中的：字符串常量和const 修饰的全局变量（全局常量）

不在全局区：局部变量（只要写在函数体内的变量都是局部变量）、const修饰的局部变量（局部常量）

讲义中的“其他常量”就是指const修饰的常量
### 程序运行后
#### 栈区 
由编译器自动分配释放，存放函数的参数值，局部变量等。

注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。

#### 堆区
由程序员分配释放， 程序结束时由操作系统回收。

C++中主要由new在堆区开辟内存 ，释放堆区的数据使用delete
```
int *func(){
int *p = new int(10); //new返回的是的是该数据类型的指针（地址），此例栈区的指针存放的堆区的地址
return p;
}
```
在堆区利用new开辟数组
```
int *p = new int(10);     //小括号创建一个变量
int *array= new int [10]; //中括号创建一个有10个变量的数组
delete[] arr;             //释放数组 delete后加[] 
```
## 引用
### 基本使用 
```
int a = 10; 看到了一块内存，占用4个字节的大小，内存中存放的数据是10，想要操作内存用a
```
引用:给变量起的别名
```
int a = 10;
int &b = a;     //数据类型 &别名 = 原名;
```
### 注意事项
1. 引用必须初始化  
2. 一旦初始化后，就不可以更改了。 
```
int a = 10;
int &b = a;   // int &b;  错误的
int c = 20;
b = c;   
```
### 引用传参
值传递：形参不会修饰实参

地址传递：形参可以修饰实参

引用传递：形参可以修饰实参  推荐，简单清楚。
```
void swap(int &a,int &b){}
swap(a,b);
```
### 引用做函数返回
1. 不要返回局部变量的引用
```
int & test1(){
  int a = 10;
  return a;
  }
  int &ref = test();   //错误，栈区的局部变量在函数执行完被释放
```
2. 如果函数的返回值是引用，函数的调用可以为左值
```
int &test2(){
  int a = 10;
  return a;
}
int &ref = test2();
test2() = 1000;
cout<<"ref = "<<ref<<endl; //输出为1000
```
### 引用的本质：指针常量
```
void func(int &ref){    //系统自动转化为int * const ref = &a;
  ref = 100;            //系统转化为*ref = 100;
}

int main(){
  int a = 10;
  int &ref = a；  //自动转化为 int * const ref = &a; 指针常量的指向不可修改。
  ref = 20;       //系统发现ref是引用自动转化为 *ref = 20;
  
  func(a);
  return 0；
}
```
### 常量引用
用来修饰**形参**，防止误操作
```
void showValue(const int&v){
  // v+=10;  使用const后防止函数中修改v导致a值改变
  cout<<v<<endl;
}

int a = 10;
//int &ref = 10;       引用必须引一块合法的内存空间可以是栈区或者堆区
int &ref = a;         //合法
const int &ref = 10;  //合法
//加上const之后 编译器将代码修改为 int temp = 10; const int &ref = temp;
//加const之后成为只读，不可修改 ref = 20; 错误

showValue(a);
```
## 函数提高
### 函数默认参数
如果自己传入了数据就用自己的数据，如果没有就用默认值。
```
// 返回值类型 函数名 （形参 = 默认值）{}
int fun01(int a, int b = 20, int c = 20){
  return a + b + c;
}
```
#### 注意事项
如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都要有默认值
```
//int fun02(int a,int b = 10,int c){ 
//}
// 错误 
```
声明和实现只能有一个默认参数（二义性，编译器不知道按照声明还是按照实现）
```
//int fun02(int a = 10,int b = 10);

//int fun02(int a = 20,int b = 20){
//}
```
### 函数的占位参数
函数中形参列表里可以有占位参数（可以有初始值）用来占位，调用函数时必须填补该位置。
```
//返回值类型 函数名（数据类型）{ }
void func(int a, int){   //void func(int a,int = 10)
}


fun(10,10); //调用时必须填补占位参数
```
### 函数重载
#### 重载概述
函数名可以相同，提高复用性。需满足的条件：
- 同一个作用域下
- 函数名称相同
- 函数参数**类型不同**或者**个数不同**或者**顺序不同**

注意：函数的返回值不可以作为函数重载的条件
#### 注意事项
- 引用作为重载条件
```
void func(int &a);
void func(const int &a); //引用可以作为函数重载的条件

int a = 10;
func(a)   //调用第一个
func(10)  //调用const的 因为引用必须是一段合法的内存空间 int &a = 10错误
```
- 函数重载碰到函数默认参数
```
void fun(int a,int b=10);
void fun(int a);


//func(10) 报错 出现二义性
```
建议：写函数重载不要加默认参数
## 类和对象
C++面向对象的三大特性为：**封装**、**继承**、**多态**
### 封装
意义：
- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制
#### 封装意义1
在设计类的时候属性和行为写在一起，表现事物。
```
class 类名{ 访问权限:  属性 / 行为}；
```
类:访问权限，属性，行为

实例化：通过一个类创建一个对象的过程

类中的属性和行为统一称为**成员**
 - 属性  也称为 成员属性/成员变量
 - 行为  也称为 成员函数/成员方法
#### 封装意义2
类在设计时，可以把属性和行为放在不同的权限下，加以控制。

访问权限有三种：
- public      公共权限 成员 类内可以访问 类外可以访问
- protetcted  保护权限 成员 类内可以访问 类外不可以访问 
- private     私有权限 成员 类内可以访问 类外不可以访问

#### class和struct
唯一区别在于默认**访问权限**不同
- struct 默认权限为公共  public
- class  默认权限为私有  private
#### 成员属性私有化
优点：
- 将成员属性设置为私有，可以自己控制读写权限
- 对于写权限，可以检测数据的有效性











